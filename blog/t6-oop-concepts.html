<!DOCTYPE html>
<head>
  <title>Matt Lao Technical Blog</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
</head>

<html id="tech">
<div>
<div id="techlogo">
<div id="social">
    <a href="https://www.facebook.com/matt.lao1"><img src="../icons/facebook.png" width ="50px"></a><a href="https://github.com/laomatt"><img src="../icons/github.png" width ="50px"</a><br><a href="https://twitter.com/LaoMatt"><img src="../icons/twitter.png" width ="50px"></a><a href="https://www.youtube.com/channel/UCEKPDwTITT16mD4ARJWFAIQ"><img src="../icons/youtube.png" width ="50px"></a></div>

  <div id="toc">
    <hr>
    <p id="navbar"><a href="#">Home</a> | <a href="#">Portfolio</a> | <a href="#">Blogs</a> | <a href="#">Contact</a> | <a href="#">About</a></p>
    <hr>
  <h2>Technical blog entries</h2>
  <li><p id="menuitem">menu items</p></li>
  <li><p id="menuitem">menu items</p></li>
  <li><p id="menuitem">menu items</p></li>
  <li><p id="menuitem">menu items</p></li>

  <h2>Cultural blog entries</h2>
  <li><p id="menuitem">menu items</p></li>
  <li><p id="menuitem">menu items</p></li>
  <li><p id="menuitem">menu items</p></li>
  <li><p id="menuitem">menu items</p></li>
  </div>
</div>
<div id="techblogbody">
  <div id="header">
    <div id="blogcontent">
      <h1>You down with OOP?  Yeah you know me! </h1>
      <h2>Ruby Modules vs. Classes</h2>

      <h3>What are Ruby Classes used for?</h3>

      <p>So like my other blog <a href="t5-ruby-classes.html">post</a> states, a class is a template for an object.  The main purpose of a class is to make objects based on itself.  It's like a cookie mold, making multiple cookies of the same shape.  One of the other uses a class has is to group variables, constans and methods that are linked to each other in some ways.  Sort of like a package, but a package that you can't open, unless you clone it and open the clone.  In other words you can't directly access things in that class without making objects from that class.</p>

<h3>What does a Ruby Module look like?</h3>

<p>A module is ruby is basically structured the same way most of everything else in ruby is structed.  There is a header and an 'end' statement to signal we are at an end of the construct.  Within those keywords reside the body of the construct, in the case of a module, this consists of constants, classes and methods. </p>
<p>Take for example a file called <b>module_demo.rb</b></p>
      <div id="example">
        <h5>--disclaimer -- this code was originally taken from <a href="http://rubymonk.com/learning/books/1-ruby-primer/chapters/35-modules/lessons/80-modules-as-namespaces">Ruby Monk</a> and modified for my own purposes --</h5><br><br>
  module Matt<br>
  def Matt.add(num1, num2)<br>
    return num2+num1<br>
  end<br>
<br>
  TANG="matt"<br>
end<br>
<br>
<br>
module Lao<br>
  def Lao.add(num1, num2)<br>
    return num2+num1*6<br>
  end<br>
<br>
  TANG="lksdfjs"<br>
end<br>
<br>
<br>
<br>
module RubyMonk<br>
  module Parser<br>
    class TextParser<br>
      def self.parse(input)<br>
        # define method<br>
        #input.upcase.chars<br>
        input.upcase.split("")<br>
      end<br>
    end<br>
  end<br>
end<br>
<br>
<br>
<br>
module Kata<br>
  A = 50<br>
  module Dojo<br>
    B = 9<br>
    A = 1<br>
<br>
    class ScopeIn<br>
      def push<br>
        A<br>
      end<br>
    end<br>
  end<br>
end<br>
<br>
A = 10<br>
<br>
</div>
<br>
<p>As you can see, the modules encapsulate a variety of different objects, from methods to contants, variables are stored inside classes which are stored inside the module.</p>
<p> We have a file for my test drivers for it:</p><br><br>

<div id="example">
require_relative 'module_demo'<br>
<br>#this first call did not work
#p RubyMonk::Parser::TextParser.new.parse("matt")<br>
p RubyMonk::Parser::TextParser.parse("matt")<br>
<br>
</div>

  <h3>had to take the 'new' keyword out</h3>
    <p><b>why?</b>  parse is a factory method, (because of the 'self.' keyword), therefore it does not of an object to be called, instead it may be called directly from the class in the modules.
    modules containt Contants, methods and classes... but not variables.</p>
<br>
<br>
<p>Now, further down out test file we have:</p>
<div id="example">
  #this first method call did not work<br>
#p Kata::Dojo::ScopeIn.push<br>
p Kata::Dojo::ScopeIn.new.push<br>
</div>
<h3>had to put the 'new' keyword in</h3>
    <p><b>why?</b> Scope in is a method that is not static, or it does not belong to the class, but rather an instance of that class.  There fore we must first instatiate an obeject (this is what the 'new' keyword does), then call the push method of that object that was just created.
    #note:  the object is anonymous, as in we never gave it an actual variable name, thus it takes up no space in memory.  After this command is executed from this temporarily instantiate object, the object effectivly dissappears.</p><br>
<br>
<br>
<br>

<h2>Why use a Module?</h2>

      <p>A class is a very useful construct, but it is not used as a package for items, and you can't group a class inside another class.  This is what modules can do.</p>

      <h3>What are Ruby Modules used for?</h3>
      <p>Modules are the packages in the Ruby language.  Modules are a way to avoid collisions in the namespace.  Module are also a way to group and call logically related constants, methods and classes.</p>

      <p>You call things in a Module via the '::' operator, which tells Ruby to look up the proceding item in the Module with the name of the preceding item.  This is usful for grouping items and calling them by group, kind of like putting things in folders and directly calling them in those folders.</p>
<h3>Selecting modules example</h3>
<p>To directly call a method that sits inside, on the first level, or a module, simply use the '::' operator in order to locate the method.  The syntax follows: 'Module_Name::Thing_your_looking_for'.  The more levels the object is down, the more '::' we to use.</p>

<p>Back in the test file we have:</p>

<div id="example">p Matt::add(3,4)  #=>prints out 7</div>

<p>now if I had another method named 'add' (because it does the same thing almost), to avoid collisions in the name space , I could put that extra 'add' method into another module called Lao (like I did in module_demo.rb), while my original 'add' method is still in the Matt module.  To call each method, I would first have to call the Module, then use the :: operator to seach with in that module.</p>


<div id="example">p Lao::add(3,4) #=>prints out 22</div>

<p>The same principle follows for the constants name TANG in each module.  Each module contains a constant named TANG, if we were to call the TANG inside Matt module, we would have to call it like this: "puts Matt::TANG" => prints "matt" while "puts Lao::TANG" =>prints "lksdfjs". </p>

<h3>Disclaimer</h3>
<p>This blog post is subject to change, as I only found out about modules this morning.</p>

</div>
    </div>
</div>
</div>

</html>